"""
THE ARCANE CODEX - Web Game Interface
Web/mobile multiplayer (1-4 players) with 100% MCP-powered dynamic scenarios

CRITICAL: NO MOCK SCENARIOS. NO STATIC CONTENT. NO FALLBACK.
ALL scenarios generated dynamically via MCP ‚Üí Claude Desktop

Uses your ‚Ç¨200 Claude Max plan - NO API key needed!
Requires MCP configuration (see MCP_SETUP.md)
"""
from flask import Flask, render_template, request, jsonify, session, send_from_directory
from flask_cors import CORS
import secrets
import random
import string
import os
from arcane_codex_server import ArcaneCodexGame, SEVEN_GODS, GameState, Character, NPCCompanion
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict, field
import json

# MCP Client for dynamic scenario generation (REQUIRED - NO MOCK FALLBACK)
try:
    from mcp_client import SyncMCPClient, generate_scenario_prompt
    MCP_AVAILABLE = True
except ImportError:
    MCP_AVAILABLE = False
    print("‚ùå MCP client not available. Game requires MCP for dynamic scenarios!")
    print("   See MCP_SETUP.md or QUICK_TEST_SETUP.md for configuration.")

# TEST MODE: Set environment variable ARCANE_TEST_MODE=1 for Playwright testing
# This enables mock interrogation questions when MCP is not available
TEST_MODE = os.environ.get('ARCANE_TEST_MODE', '0') == '1'
if TEST_MODE:
    print("‚ö†Ô∏è  TEST MODE ENABLED - Using mock interrogation questions")
    print("   Set ARCANE_TEST_MODE=0 or unset to require MCP")

app = Flask(__name__)

# FIXED: Persist secret key to survive server restarts
SECRET_KEY_FILE = "flask_secret.key"
if os.path.exists(SECRET_KEY_FILE):
    with open(SECRET_KEY_FILE, 'r') as f:
        app.secret_key = f.read().strip()
    print(f"[OK] Loaded persisted secret key from {SECRET_KEY_FILE}")
else:
    app.secret_key = secrets.token_hex(32)
    with open(SECRET_KEY_FILE, 'w') as f:
        f.write(app.secret_key)
    print(f"[OK] Generated and saved new secret key to {SECRET_KEY_FILE}")

CORS(app)

# ============================================================================
# DEVELOPMENT: Cache Prevention Configuration
# ============================================================================

# Disable static file caching in debug mode
if app.debug:
    app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0
    print("[DEV MODE] Static file caching DISABLED for development")

@app.after_request
def prevent_dev_caching(response):
    """
    Prevent aggressive browser caching during development

    ISSUE: Browsers cache static/rpg_game.html aggressively
    - User edits file
    - Server restarts
    - Browser shows old version (HTTP 304 Not Modified)
    - Playwright with fresh context shows correct version

    SOLUTION:
    - Disable all caching in debug mode
    - Remove ETags (prevents 304 responses)
    - Force revalidation on every request

    PRODUCTION: This only runs in debug mode (production unaffected)
    """
    if app.debug:
        # Prevent caching
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'

        # Remove ETags that cause 304 Not Modified responses
        response.headers.pop('ETag', None)
        response.headers.pop('Last-Modified', None)

    return response

# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class PlayerChoice:
    """Tracks a player's choice for the current turn"""
    player_id: str
    choice: str
    timestamp: float

@dataclass
class Scenario:
    """MCP-generated scenario"""
    scenario_id: str
    public_scene: str  # What everyone sees
    whispers: Dict[str, str]  # player_id -> private whisper
    theme: str  # e.g., "betrayal", "sacrifice", "greed"
    turn_number: int
    choices_submitted: Dict[str, PlayerChoice] = field(default_factory=dict)
    resolved: bool = False

@dataclass
class GameSession:
    """Multiplayer game session"""
    code: str
    game: ArcaneCodexGame
    players: Dict[str, str]  # player_id -> player_name
    player_classes: Dict[str, str]  # player_id -> class
    max_players: int = 4
    game_started: bool = False
    current_scenario: Optional[Scenario] = None
    scenario_history: List[str] = field(default_factory=list)  # Track previous themes
    interrogation_complete: set = field(default_factory=set)  # Track who completed interrogation

    def is_full(self) -> bool:
        """Check if game is at max capacity"""
        return len(self.players) >= self.max_players

    def all_players_ready(self) -> bool:
        """Check if all players have completed character creation"""
        return len(self.player_classes) == len(self.players) and len(self.players) > 0

    def all_choices_submitted(self) -> bool:
        """Check if all players have submitted their choices"""
        if not self.current_scenario:
            return False
        return len(self.current_scenario.choices_submitted) == len(self.players)

    def get_waiting_players(self) -> List[str]:
        """Get list of players who haven't submitted choices"""
        if not self.current_scenario:
            return []
        submitted = set(self.current_scenario.choices_submitted.keys())
        all_players = set(self.players.keys())
        return list(all_players - submitted)

# ============================================================================
# TEST MODE: Mock Interrogation Questions
# ============================================================================
# ONLY used when ARCANE_TEST_MODE=1 environment variable is set
# Production ALWAYS requires MCP for 100% unique AI-generated questions

MOCK_INTERROGATION_QUESTIONS = [
    {
        "question_number": 1,
        "question_text": "A comrade lies dying. Their final wish is to reveal a secret that could save the party or doom them. Do you listen?",
        "options": [
            {
                "id": "q1_a",
                "letter": "A",
                "text": "Listen carefully - knowledge is power",
                "favor": {"Myrth": 2, "Gorath": -1}
            },
            {
                "id": "q1_b",
                "letter": "B",
                "text": "Refuse - some secrets are better buried",
                "favor": {"Althara": 2, "Gorath": 1}
            },
            {
                "id": "q1_c",
                "letter": "C",
                "text": "End their suffering before they speak",
                "favor": {"Gorath": 2, "Vexor": 1}
            }
        ]
    },
    {
        "question_number": 2,
        "question_text": "You discover your companion has been stealing from the party treasury. They claim it's for their sick child.",
        "options": [
            {
                "id": "q2_a",
                "letter": "A",
                "text": "Expose them to the group immediately",
                "favor": {"Nerys": 2, "Vexor": -1}
            },
            {
                "id": "q2_b",
                "letter": "B",
                "text": "Confront them privately and demand repayment",
                "favor": {"Valrik": 2, "Nerys": 1}
            },
            {
                "id": "q2_c",
                "letter": "C",
                "text": "Say nothing and secretly add your own gold",
                "favor": {"Althara": 3, "Gorath": -2}
            }
        ]
    }
]

def get_mock_interrogation_question(question_number: int, previous_answers: list = None) -> dict:
    """
    Generate mock interrogation question for testing

    ONLY USED IN TEST MODE (ARCANE_TEST_MODE=1)
    Production uses 100% AI-generated questions via MCP
    """
    if question_number <= len(MOCK_INTERROGATION_QUESTIONS):
        return MOCK_INTERROGATION_QUESTIONS[question_number - 1]

    # If we run out of mock questions, cycle back
    index = (question_number - 1) % len(MOCK_INTERROGATION_QUESTIONS)
    question = MOCK_INTERROGATION_QUESTIONS[index].copy()
    question["question_number"] = question_number
    return question

# Active game sessions
game_sessions: Dict[str, GameSession] = {}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def generate_game_code() -> str:
    """Generate unique 6-character game code"""
    while True:
        code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))
        if code not in game_sessions:
            return code

def get_player_id() -> str:
    """Get or create player ID for current session"""
    if 'player_id' not in session:
        session['player_id'] = secrets.token_hex(16)
    return session['player_id']

def get_game_session(game_code: str) -> Optional[GameSession]:
    """Get game session by code"""
    return game_sessions.get(game_code)

def generate_scenario_via_mcp(game_session: GameSession) -> Scenario:
    """
    Generate dynamic scenario using MCP ‚Üí Claude Desktop (‚Ç¨200 Max plan)

    NO MOCK SCENARIOS. NO FALLBACK. MCP ONLY.

    If MCP is not configured, this will raise an exception with setup instructions.
    """

    if not MCP_AVAILABLE:
        raise RuntimeError(
            "‚ùå MCP client not available!\n\n"
            "This game requires MCP (Model Context Protocol) for 100% dynamic scenarios.\n"
            "NO static/mock scenarios are used.\n\n"
            "To configure MCP:\n"
            "1. See MCP_SETUP.md for full instructions\n"
            "2. Or see QUICK_TEST_SETUP.md for quick start\n\n"
            "Your ‚Ç¨200 Claude Max plan provides unlimited dynamic scenarios via MCP."
        )

    # Gather game context
    party_trust = game_session.game.game_state.party_trust if game_session.game.game_state else 50
    player_classes = list(game_session.player_classes.values())
    previous_themes = game_session.scenario_history[-3:] if game_session.scenario_history else []

    # Prepare NPC data
    npcs = []
    if game_session.game.game_state and game_session.game.game_state.npc_companions:
        for npc in game_session.game.game_state.npc_companions:
            npcs.append({
                "name": npc.name,
                "approval": npc.approval
            })

    # Prepare divine favor
    divine_favor = {}
    if game_session.game.interrogations:
        # Get first player's divine favor as reference
        first_player = list(game_session.players.keys())[0]
        if first_player in game_session.game.interrogations:
            divine_favor = game_session.game.interrogations[first_player].divine_favor

    # Create MCP client
    mcp_client = SyncMCPClient()

    # Generate via MCP (uses ‚Ç¨200 Max plan)
    try:
        scenario_data = mcp_client.generate_scenario(
            party_trust=party_trust,
            player_classes=player_classes,
            npcs=npcs,
            divine_favor=divine_favor,
            previous_themes=previous_themes,
            location=game_session.game.game_state.current_location if game_session.game.game_state else "Unknown",
            difficulty="medium"
        )
    except Exception as e:
        raise RuntimeError(
            f"‚ùå MCP scenario generation failed!\n\n"
            f"Error: {e}\n\n"
            f"Possible causes:\n"
            f"1. MCP server not configured in Claude Desktop\n"
            f"2. Claude Desktop not running\n"
            f"3. MCP server script path incorrect\n\n"
            f"See MCP_SETUP.md for troubleshooting."
        )

    # Extract whispers for each player
    whispers = {}
    for player_id, player_class in game_session.player_classes.items():
        base_class = player_class.split(" ")[0].lower()  # "Fighter (Lawful)" ‚Üí "fighter"
        whisper = scenario_data.get("player_whispers", {}).get(base_class, "")
        whispers[player_id] = whisper

    # Create scenario from MCP response
    return Scenario(
        scenario_id=scenario_data.get("scenario_id", f"mcp_{secrets.token_hex(8)}"),
        public_scene=scenario_data.get("public_scene", ""),
        whispers=whispers,
        theme=scenario_data.get("theme", "dynamic"),
        turn_number=len(game_session.scenario_history) + 1
    )

# ============================================================================
# AUTHENTICATION ENDPOINTS
# ============================================================================

@app.route('/favicon.ico')
def favicon():
    """Serve favicon to prevent 404 console errors"""
    return send_from_directory('static', 'favicon.ico', mimetype='image/vnd.microsoft.icon')

@app.route('/api/set_username', methods=['POST'])
def set_username():
    """Set username for the player (simple auth - no password)"""
    data = request.json or {}
    username = data.get('username', '').strip()

    if not username:
        return jsonify({'status': 'error', 'message': 'Username required'}), 400

    if len(username) < 2:
        return jsonify({'status': 'error', 'message': 'Username must be at least 2 characters'}), 400

    if len(username) > 20:
        return jsonify({'status': 'error', 'message': 'Username must be at most 20 characters'}), 400

    # Store username in session
    session['username'] = username

    return jsonify({
        'status': 'success',
        'username': username,
        'message': f'Welcome, {username}!'
    })

@app.route('/api/get_username', methods=['GET'])
def get_username():
    """Get current username from session"""
    username = session.get('username')

    if not username:
        return jsonify({'status': 'success', 'username': None})

    return jsonify({
        'status': 'success',
        'username': username
    })

# ============================================================================
# MULTIPLAYER SESSION ENDPOINTS
# ============================================================================

@app.route('/api/create_game', methods=['POST'])
def create_game():
    """Create new multiplayer game session"""
    try:
        # Get username from session (required)
        username = session.get('username')
        if not username:
            return jsonify({'status': 'error', 'message': 'Username required. Please set username first.'}), 400

        # Get JSON data (may be None if no body sent)
        try:
            data = request.get_json(silent=True) or {}
        except:
            data = {}

        player_name = username  # Use session username instead of request data

        # Generate game code
        code = generate_game_code()

        # Get or create player ID
        player_id = get_player_id()

        # Create new game
        print(f"[DEBUG] Creating ArcaneCodexGame instance for code {code}")
        game = ArcaneCodexGame()
        print(f"[DEBUG] Game instance created successfully")

        game_session = GameSession(
            code=code,
            game=game,
            players={player_id: player_name},
            player_classes={}
        )

        game_sessions[code] = game_session

        # Store game code in session
        session['game_code'] = code

        print(f"[DEBUG] Game {code} created successfully for player {player_name}")

        return jsonify({
            'status': 'success',
            'game_code': code,
            'player_id': player_id,
            'player_name': player_name,
            'message': f'Game created! Share code {code} with friends (up to 3 more players)'
        })

    except Exception as e:
        print(f"[ERROR] Failed to create game: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'status': 'error',
            'message': f'Failed to create game: {str(e)}'
        }), 500

@app.route('/api/join_game', methods=['POST'])
def join_game():
    """Join existing game session"""
    # Get username from session (required)
    username = session.get('username')
    if not username:
        return jsonify({'status': 'error', 'message': 'Username required. Please set username first.'}), 400

    data = request.json
    game_code = data.get('game_code', '').upper()
    player_name = username  # Use session username

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Game code required'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    if game_session.is_full():
        return jsonify({'status': 'error', 'message': 'Game is full (4 players max)'}), 400

    if game_session.game_started:
        return jsonify({'status': 'error', 'message': 'Game already started'}), 400

    # Get or create player ID
    player_id = get_player_id()

    # Check if player already in game
    if player_id in game_session.players:
        return jsonify({
            'status': 'success',
            'game_code': game_code,
            'player_id': player_id,
            'message': 'Already in this game',
            'players': list(game_session.players.values())
        })

    # Add player to game
    game_session.players[player_id] = player_name
    session['game_code'] = game_code

    return jsonify({
        'status': 'success',
        'game_code': game_code,
        'player_id': player_id,
        'player_name': player_name,
        'message': f'Joined game {game_code}!',
        'players': list(game_session.players.values()),
        'player_count': len(game_session.players)
    })

@app.route('/api/session_info', methods=['GET'])
def session_info():
    """Get current session info"""
    game_code = session.get('game_code')
    player_id = get_player_id()

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    # Build player info
    players_info = []
    for pid, pname in game_session.players.items():
        player_info = {
            'player_id': pid,
            'player_name': pname,
            'is_you': pid == player_id
        }

        # Add class if assigned
        if pid in game_session.player_classes:
            player_info['class'] = game_session.player_classes[pid]

        players_info.append(player_info)

    return jsonify({
        'status': 'success',
        'game_code': game_code,
        'player_id': player_id,
        'player_count': len(game_session.players),
        'max_players': game_session.max_players,
        'is_full': game_session.is_full(),
        'game_started': game_session.game_started,
        'all_ready': game_session.all_players_ready(),
        'players': players_info
    })

# ============================================================================
# MCP SCENARIO GENERATION
# ============================================================================

@app.route('/api/generate_scenario', methods=['POST'])
def generate_scenario():
    """
    Generate new scenario using MCP ‚Üí Claude Desktop

    100% DYNAMIC. NO MOCK SCENARIOS. NO FALLBACK.

    Requires MCP configured (see MCP_SETUP.md)
    Uses your ‚Ç¨200 Claude Max plan for unlimited unique scenarios
    """
    game_code = session.get('game_code')

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    if not game_session.all_players_ready():
        return jsonify({'status': 'error', 'message': 'Not all players ready'}), 400

    # Generate scenario via MCP (100% dynamic, NO mock scenarios)
    try:
        scenario = generate_scenario_via_mcp(game_session)
    except RuntimeError as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

    # Store scenario
    game_session.current_scenario = scenario
    game_session.scenario_history.append(scenario.theme)

    return jsonify({
        'status': 'success',
        'scenario_id': scenario.scenario_id,
        'theme': scenario.theme,
        'turn_number': scenario.turn_number,
        'message': 'Scenario generated! View with /api/current_scenario'
    })

# ============================================================================
# SCENARIO DISPLAY
# ============================================================================

@app.route('/api/current_scenario', methods=['GET'])
def current_scenario():
    """Get current scenario public scene (what everyone sees)"""
    game_code = session.get('game_code')

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    if not game_session.current_scenario:
        return jsonify({'status': 'error', 'message': 'No active scenario'}), 404

    scenario = game_session.current_scenario

    return jsonify({
        'status': 'success',
        'scenario_id': scenario.scenario_id,
        'public_scene': scenario.public_scene,
        'theme': scenario.theme,
        'turn_number': scenario.turn_number,
        'resolved': scenario.resolved,
        'choices_submitted': len(scenario.choices_submitted),
        'total_players': len(game_session.players)
    })

@app.route('/api/my_whisper', methods=['GET'])
def my_whisper():
    """Get player's private whisper (class-specific secret info)"""
    game_code = session.get('game_code')
    player_id = get_player_id()

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    if not game_session.current_scenario:
        return jsonify({'status': 'error', 'message': 'No active scenario'}), 404

    scenario = game_session.current_scenario
    whisper = scenario.whispers.get(player_id, "You sense nothing special...")

    return jsonify({
        'status': 'success',
        'whisper': whisper,
        'player_class': game_session.player_classes.get(player_id, 'Unknown'),
        'message': 'This is YOUR SECRET. Share it... or don\'t.'
    })

# ============================================================================
# TURN-BASED CHOICES
# ============================================================================

@app.route('/api/make_choice', methods=['POST'])
def make_choice():
    """Submit player's choice for current turn"""
    game_code = session.get('game_code')
    player_id = get_player_id()

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    # FIXED: Verify player is actually in this game (prevents hijacking)
    if player_id not in game_session.players:
        return jsonify({'status': 'error', 'message': 'You are not in this game'}), 403

    if not game_session.current_scenario:
        return jsonify({'status': 'error', 'message': 'No active scenario'}), 404

    if game_session.current_scenario.resolved:
        return jsonify({'status': 'error', 'message': 'Scenario already resolved'}), 400

    # FIXED: Prevent duplicate submissions
    if player_id in game_session.current_scenario.choices_submitted:
        return jsonify({'status': 'error', 'message': 'You have already submitted your choice'}), 400

    data = request.json
    choice = data.get('choice', '').strip()

    if not choice:
        return jsonify({'status': 'error', 'message': 'Choice required'}), 400

    # FIXED: Validate choice length (prevent DOS attacks)
    if len(choice) > 1000:
        return jsonify({'status': 'error', 'message': 'Choice too long (max 1000 characters)'}), 400

    # FIXED: Sanitize HTML to prevent XSS
    import html
    choice = html.escape(choice)

    # Record choice
    import time
    player_choice = PlayerChoice(
        player_id=player_id,
        choice=choice,
        timestamp=time.time()
    )

    game_session.current_scenario.choices_submitted[player_id] = player_choice

    all_submitted = game_session.all_choices_submitted()

    return jsonify({
        'status': 'success',
        'message': 'Choice submitted!',
        'choices_submitted': len(game_session.current_scenario.choices_submitted),
        'total_players': len(game_session.players),
        'all_submitted': all_submitted,
        'waiting_for': game_session.get_waiting_players()
    })

@app.route('/api/waiting_for', methods=['GET'])
def waiting_for():
    """Check which players haven't submitted choices yet"""
    game_code = session.get('game_code')

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    if not game_session.current_scenario:
        return jsonify({'status': 'error', 'message': 'No active scenario'}), 404

    waiting = game_session.get_waiting_players()
    waiting_names = [game_session.players[pid] for pid in waiting]

    return jsonify({
        'status': 'success',
        'waiting_player_ids': waiting,
        'waiting_player_names': waiting_names,
        'choices_submitted': len(game_session.current_scenario.choices_submitted),
        'total_players': len(game_session.players),
        'all_submitted': game_session.all_choices_submitted()
    })

@app.route('/api/resolve_turn', methods=['POST'])
def resolve_turn():
    """
    Resolve turn once all players have made choices

    TODO: This should:
    1. Send all choices to MCP
    2. Get narrative outcome from Claude
    3. Update game state (trust, NPC approval, etc.)
    4. Trigger Divine Council if needed
    5. Return results
    """
    game_code = session.get('game_code')

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    if not game_session.current_scenario:
        return jsonify({'status': 'error', 'message': 'No active scenario'}), 404

    if not game_session.all_choices_submitted():
        return jsonify({
            'status': 'error',
            'message': 'Not all players have submitted choices',
            'waiting_for': game_session.get_waiting_players()
        }), 400

    scenario = game_session.current_scenario

    # Mark as resolved
    scenario.resolved = True

    # Gather choices for MCP resolution
    choices_summary = {}
    for pid, pchoice in scenario.choices_submitted.items():
        player_name = game_session.players[pid]
        player_class = game_session.player_classes[pid]
        whisper = scenario.whispers.get(pid, "")
        choices_summary[player_name] = {
            'class': player_class,
            'choice': pchoice.choice,
            'whisper_received': whisper
        }

    # Send to MCP for resolution (100% dynamic outcome)
    # TODO: Create resolve_turn_via_mcp() similar to generate_scenario_via_mcp()
    # For now: Basic resolution with trust calculation

    # Calculate trust change based on choice alignment
    choices = [c.choice.lower() for c in scenario.choices_submitted.values()]

    # Simple heuristic: aligned choices = trust increase
    unique_choices = len(set(choices))
    if unique_choices == 1:
        trust_change = 10  # Perfect alignment
    elif unique_choices == 2:
        trust_change = 0   # Some disagreement
    else:
        trust_change = -10  # Major conflict

    if game_session.game.game_state:
        game_session.game.update_trust(trust_change, f"Turn {scenario.turn_number} resolution")

    # Placeholder outcome (MCP resolution integration needed)
    outcome = f"""
TURN {scenario.turn_number} RESOLVED

The party's choices have consequences...

Trust: {trust_change:+d} (now {game_session.game.game_state.party_trust if game_session.game.game_state else 50}/100)

[Full narrative outcome will be generated by MCP in future update]
"""

    return jsonify({
        'status': 'success',
        'resolved': True,
        'outcome': outcome,
        'choices_made': choices_summary,
        'trust_change': trust_change,
        'message': 'Turn resolved! Generate next scenario when ready.'
    })

# ============================================================================
# EXISTING ENDPOINTS (Divine Interrogation + Game State)
# ============================================================================

@app.route('/')
def index():
    """RPG Game Main Menu"""
    return send_from_directory('static', 'rpg_game.html')

@app.route('/boring')
def boring_version():
    """The old boring HTML version - DEPRECATED"""
    return render_template('index.html')

@app.route('/game')
def game():
    """Main game page"""
    return render_template('game.html')

@app.route('/api/start_interrogation', methods=['POST'])
def start_interrogation():
    """Start Divine Interrogation for a player - AI GENERATED ONLY!"""
    game_code = session.get('game_code')
    player_id = get_player_id()

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    # Initialize interrogation progress if not exists
    if player_id not in game_session.game.divine_interrogation_progress:
        game_session.game.divine_interrogation_progress[player_id] = {
            "answers": [],
            "current_question": 0,
            "divine_favor": {god: 0 for god in SEVEN_GODS},
            "questions": []  # Store AI-generated questions
        }

    # Generate first question via MCP (or mock in test mode)
    if not MCP_AVAILABLE and not TEST_MODE:
        raise RuntimeError(
            "‚ùå MCP client not available!\n\n"
            "Divine Interrogation requires MCP for 100% unique questions per player.\n"
            "NO static questions are used.\n\n"
            "See MCP_SETUP.md for configuration.\n"
            "For testing, set ARCANE_TEST_MODE=1 environment variable."
        )

    try:
        if TEST_MODE and not MCP_AVAILABLE:
            # Use mock questions for testing
            print(f"‚ö†Ô∏è  TEST MODE: Using mock interrogation question for player {player_id[:8]}")
            question_data = get_mock_interrogation_question(
                question_number=1,
                previous_answers=[]
            )
        else:
            # Production: Use MCP for AI-generated questions
            mcp_client = SyncMCPClient()
            question_data = mcp_client.generate_interrogation_question(
                player_id=player_id,
                question_number=1,
                previous_answers=[]
            )

        # Store generated question
        game_session.game.divine_interrogation_progress[player_id]["questions"].append(question_data)

        return jsonify({
            'status': 'success',
            'message': 'üå©Ô∏è The Seven Gods await your truth...',
            'question': question_data
        })
    except Exception as e:
        raise RuntimeError(
            f"‚ùå MCP interrogation question generation failed!\n\n"
            f"Error: {e}\n\n"
            f"See MCP_SETUP.md for troubleshooting."
        )

@app.route('/api/answer_question', methods=['POST'])
def answer_question():
    """Answer a Divine Interrogation question - AI GENERATED ONLY!"""
    game_code = session.get('game_code')
    player_id = get_player_id()

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    data = request.json
    answer_id = data.get('answer_id')

    progress = game_session.game.divine_interrogation_progress.get(player_id)
    if not progress:
        return jsonify({'status': 'error', 'message': 'Interrogation not started'}), 400

    # Get current question from stored AI-generated questions
    current_index = progress["current_question"]
    if current_index >= len(progress["questions"]):
        return jsonify({'status': 'error', 'message': 'Invalid question index'}), 400

    current_question = progress["questions"][current_index]

    # Find selected option and update divine favor
    selected_option = None
    for option in current_question.get("options", []):
        if option["id"] == answer_id:
            selected_option = option
            break

    if not selected_option:
        return jsonify({'status': 'error', 'message': 'Invalid answer ID'}), 400

    # Update divine favor based on selected option
    for god, favor_change in selected_option.get("favor", {}).items():
        progress["divine_favor"][god] = progress["divine_favor"].get(god, 0) + favor_change

    # Record answer
    progress["answers"].append({
        "question_number": current_question.get("question_number", current_index + 1),
        "answer_id": answer_id,
        "answer_text": selected_option["text"]
    })

    # Move to next question
    progress["current_question"] += 1

    # Check if interrogation complete (10 questions)
    if progress["current_question"] >= 10:
        # INTERROGATION COMPLETE - Determine character class from divine favor
        divine_favor = progress["divine_favor"]

        # Find god with highest favor
        max_favor = max(divine_favor.values())
        top_god = [god for god, favor in divine_favor.items() if favor == max_favor][0]

        # Map god to character class (simplified)
        god_to_class = {
            "VALDRIS": "Fighter",
            "KAITHA": "Thief",
            "MORVANE": "Cleric",
            "SYLARA": "Mage",
            "KORVAN": "Fighter",
            "ATHENA": "Mage",
            "MERCUS": "Thief"
        }
        character_class = god_to_class.get(top_god, "Fighter")

        # Get player name from session
        player_name = game_session.players[player_id]

        # Create character with determined class
        character = game_session.game.create_character(player_id, player_name)
        character.character_class = character_class  # Override with AI-determined class

        # Store character class
        game_session.player_classes[player_id] = character.character_class

        # Mark interrogation as complete for this player
        game_session.interrogation_complete.add(player_id)

        # Check if all players ready to start
        all_ready = game_session.all_players_ready()

        # Initialize game state if all ready
        if all_ready and not game_session.game_started:
            # Create characters list
            characters = []
            for pid in game_session.players.keys():
                pname = game_session.players[pid]
                char = game_session.game.create_character(pid, pname)
                characters.append(char)

            # Create NPCs
            npcs = game_session.game.create_default_npcs()

            # Initialize game state
            game_session.game.game_state = GameState(
                party_id=game_code,
                player_characters=characters,
                npc_companions=npcs,
                party_trust=50,
                party_leader=list(game_session.players.keys())[0],
                current_location="valdria_town"
            )

            game_session.game_started = True

        return jsonify({
            'status': 'complete',
            'assigned_class': character_class,
            'character_class': character_class,
            'divine_favor': divine_favor,
            'character': {
                'name': character.name,
                'class': character.character_class,
                'hp': character.hp,
                'mana': character.mana
            },
            'all_ready': all_ready,
            'game_started': game_session.game_started
        })

    else:
        # CONTINUE - Generate next question via MCP (or mock in test mode)
        try:
            if TEST_MODE and not MCP_AVAILABLE:
                # Use mock questions for testing
                print(f"‚ö†Ô∏è  TEST MODE: Using mock interrogation question {progress['current_question'] + 1} for player {player_id[:8]}")
                next_question = get_mock_interrogation_question(
                    question_number=progress["current_question"] + 1,
                    previous_answers=progress["answers"]
                )
            else:
                # Production: Use MCP for AI-generated questions
                mcp_client = SyncMCPClient()
                next_question = mcp_client.generate_interrogation_question(
                    player_id=player_id,
                    question_number=progress["current_question"] + 1,
                    previous_answers=progress["answers"]
                )

            # Store generated question
            progress["questions"].append(next_question)

            return jsonify({
                'status': 'continue',
                'next_question': next_question
            })
        except Exception as e:
            raise RuntimeError(
                f"‚ùå MCP interrogation question generation failed!\n\n"
                f"Error: {e}\n\n"
                f"See MCP_SETUP.md for troubleshooting."
            )

@app.route('/api/game_state', methods=['GET'])
def get_game_state():
    """Get current game state (enhanced with scenario info)"""
    game_code = session.get('game_code')

    if not game_code:
        return jsonify({'status': 'error', 'message': 'Not in a game'}), 400

    game_session = get_game_session(game_code)

    if not game_session:
        return jsonify({'status': 'error', 'message': 'Game not found'}), 404

    player_id = get_player_id()

    # Backward compatibility: Initialize interrogation_complete for old sessions
    if not hasattr(game_session, 'interrogation_complete'):
        game_session.interrogation_complete = set()

    # Check if this player has completed interrogation
    player_interrogation_complete = player_id in game_session.interrogation_complete
    all_players_interrogation_done = len(game_session.interrogation_complete) == len(game_session.players)

    # PHASE 1: PARTY/INTERROGATION - Before game starts
    if not game_session.game.game_state:
        # Determine sub-phase: lobby (waiting) vs interrogation (character creation)
        if player_interrogation_complete:
            # This player is done, waiting for others
            phase = 'lobby'
        else:
            # This player still needs to do interrogation
            phase = 'interrogation'

        return jsonify({
            'status': 'active',
            'phase': phase,
            'interrogation_complete': player_interrogation_complete,
            'game_code': game_code,
            'trust_level': 100,
            'players': [
                {
                    'name': pname,
                    'class': game_session.player_classes.get(pid, 'Unknown'),
                    'ready': pid in game_session.interrogation_complete
                }
                for pid, pname in game_session.players.items()
            ],
            'all_players_ready': all_players_interrogation_done
        })

    # PHASE 2: GAME STARTED - Scenario gameplay
    game_state = game_session.game.game_state

    response = {
        'status': 'active',
        'phase': 'scenario',  # Game has started, we're in scenario phase
        'game_code': game_code,
        'party_trust': game_state.party_trust,
        'trust_level': game_state.party_trust,
        'location': game_state.current_location,
        'turn': game_state.turn_count,
        'players': [
            {
                'name': pc.name,
                'class': pc.character_class,
                'hp': pc.hp,
                'hp_max': pc.hp_max,
                'mana': pc.mana,
                'mana_max': pc.mana_max
            }
            for pc in game_state.player_characters
        ],
        'npcs': [
            {
                'name': npc.name,
                'title': npc.title,
                'approval': npc.approval,
                'is_alive': npc.is_alive
            }
            for npc in game_state.npc_companions
        ]
    }

    # Add current scenario info if exists
    if game_session.current_scenario:
        response['current_scenario'] = {
            'scenario_id': game_session.current_scenario.scenario_id,
            'theme': game_session.current_scenario.theme,
            'turn_number': game_session.current_scenario.turn_number,
            'resolved': game_session.current_scenario.resolved,
            'choices_submitted': len(game_session.current_scenario.choices_submitted),
            'total_players': len(game_session.players)
        }

    return jsonify(response)

# ============================================================================
# SERVER START
# ============================================================================

if __name__ == '__main__':
    print("""
===============================================================
    THE ARCANE CODEX - TRUE ASCII GRAPHICS ONLY!
===============================================================

Starting REAL ASCII game server (NO BORING HTML!)...

Open your browser to: http://localhost:5000

TRUE ASCII FEATURES:
- Green phosphor terminal display (like REAL terminals!)
- CRT monitor scanline effects
- Screen shake on impacts
- ASCII particle explosions
- Rhythm engine pulsing at 120 BPM
- 30 FPS animated ASCII graphics
- REAL ASCII art (not HTML pretending!)

MULTIPLAYER:
- 1-4 players with ASCII interface
- Asymmetric whispers in ASCII
- Trust mechanics with ASCII bars

IMPORTANT: Requires MCP configured (see MCP_SETUP.md)
           Uses your ‚Ç¨200 Claude Max plan for unlimited scenarios

API ENDPOINTS READY:

Session Management:
  POST /api/create_game - Create new game session
  POST /api/join_game - Join existing game
  GET /api/session_info - Get session info

Character Creation:
  POST /api/start_interrogation - Begin Divine Interrogation
  POST /api/answer_question - Answer interrogation question

Scenarios:
  POST /api/generate_scenario - Generate new scenario
  GET /api/current_scenario - Get public scene
  GET /api/my_whisper - Get your private whisper

Turns:
  POST /api/make_choice - Submit your choice
  GET /api/waiting_for - Check who hasn't chosen
  POST /api/resolve_turn - Resolve turn (all choices in)

Game State:
  GET /api/game_state - Get full game state

===============================================================
""")

    # Disable auto-reload to prevent game sessions from being wiped
    app.run(debug=True, host='0.0.0.0', port=5000, use_reloader=False)

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Game Flow Demo - The Arcane Codex</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Yrsa:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Yrsa', serif;
            background: linear-gradient(180deg, #0A0812 0%, #1A1425 100%);
            color: #D4AF37;
            overflow-x: hidden;
        }

        /* === NARRATIVE TEXT SECTIONS === */
        .narrative-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 40px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .narrative-text {
            font-size: 20px;
            line-height: 1.8;
            color: #D4AF37;
            margin-bottom: 30px;
            text-align: justify;
            animation: fadeIn 1s ease-in;
        }

        .narrative-text p {
            margin-bottom: 20px;
        }

        .narrative-title {
            font-family: 'Cinzel', serif;
            font-size: 42px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .choice-section {
            margin-top: 40px;
            padding: 30px;
            background: rgba(42, 36, 30, 0.6);
            border: 2px solid #5C4A3A;
            border-radius: 8px;
        }

        .choice-button {
            display: block;
            width: 100%;
            padding: 20px;
            margin: 15px 0;
            background: linear-gradient(135deg, #2A1810 0%, #5C4A3A 100%);
            border: 2px solid #D4AF37;
            color: #D4AF37;
            font-family: 'Cinzel', serif;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .choice-button:hover {
            background: linear-gradient(135deg, #3A2820 0%, #6C5A4A 100%);
            border-color: #FFD700;
            color: #FFD700;
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }

        /* === THREE.JS SCENE CONTAINER === */
        .threejs-scene-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: none;
            background: #000;
        }

        .threejs-scene-container.active {
            display: block;
        }

        #threejs-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .scene-overlay-text {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
            animation: fadeIn 1s ease-in 1s both;
        }

        .scene-overlay-text h2 {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            color: #FFD700;
            text-shadow:
                0 0 20px rgba(255, 215, 0, 0.8),
                0 0 40px rgba(255, 215, 0, 0.5);
            margin-bottom: 20px;
        }

        .scene-overlay-text p {
            font-size: 24px;
            color: #D4AF37;
            max-width: 700px;
        }

        .skip-scene {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(42, 36, 30, 0.8);
            border: 1px solid #5C4A3A;
            color: #8B7355;
            font-family: 'Yrsa', serif;
            cursor: pointer;
            border-radius: 4px;
            z-index: 10;
        }

        .skip-scene:hover {
            background: rgba(42, 36, 30, 1);
            color: #D4AF37;
        }

        /* === FLOW INDICATOR === */
        .flow-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(42, 36, 30, 0.95);
            border: 2px solid #5C4A3A;
            padding: 15px 25px;
            border-radius: 8px;
            font-family: 'Cinzel', serif;
            z-index: 100;
        }

        .flow-step {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            color: #5C4A3A;
            font-size: 14px;
        }

        .flow-step.active {
            color: #FFD700;
            font-weight: 600;
        }

        .flow-step.completed {
            color: #8B7355;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #D4AF37;
            font-size: 24px;
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <!-- Flow Indicator -->
    <div class="flow-indicator">
        <div class="flow-step" id="step1">üìñ Story Introduction</div>
        <div class="flow-step" id="step2">üé≠ 3D Divine Council</div>
        <div class="flow-step" id="step3">‚öñÔ∏è Council Votes</div>
        <div class="flow-step" id="step4">üìú Resolution</div>
    </div>

    <!-- SECTION 1: Narrative Introduction -->
    <div class="narrative-container" id="section1">
        <h1 class="narrative-title">Chapter 3: The Judgment</h1>

        <div class="narrative-text">
            <p>The ancient corridors echo with your footsteps as you descend deeper into the temple. The air grows thick with an otherworldly presence. Runes along the walls begin to glow with ethereal light, pulsing in rhythm with your heartbeat.</p>

            <p>Your party stands before massive obsidian doors, each emblazoned with the symbols of the Seven Divine Gods. The betrayal you committed in the last quest has not gone unnoticed. The gods have been watching.</p>

            <p>As your hand touches the cold stone, the doors begin to swing open on their own. A voice‚Äîno, seven voices speaking as one‚Äîfills your mind:</p>

            <p style="text-align: center; font-style: italic; color: #FFD700; font-size: 24px; margin: 30px 0;">
                "Enter. Face judgment."
            </p>
        </div>

        <div class="choice-section">
            <h3 style="font-family: 'Cinzel', serif; color: #D4AF37; margin-bottom: 20px;">What do you do?</h3>
            <button class="choice-button" onclick="enterCouncil()">
                ‚öîÔ∏è Enter the Divine Council Chamber
            </button>
            <button class="choice-button" onclick="enterCouncil()">
                üôè Approach humbly and seek mercy
            </button>
            <button class="choice-button" onclick="enterCouncil()">
                üó°Ô∏è Draw your weapon and prepare for the worst
            </button>
        </div>
    </div>

    <!-- SECTION 2: Three.js 3D Scene -->
    <div class="threejs-scene-container" id="threejs-section">
        <button class="skip-scene" onclick="skipScene()">Skip Scene ‚Üí</button>
        <canvas id="threejs-canvas"></canvas>
        <div class="scene-overlay-text">
            <h2>THE DIVINE COUNCIL</h2>
            <p>Seven gods manifest before you, their judgment imminent...</p>
        </div>
        <div class="loading" id="loading">Loading Divine Council...</div>
    </div>

    <!-- SECTION 3: Post-Council Narrative -->
    <div class="narrative-container" id="section3" style="display: none;">
        <h1 class="narrative-title">The Verdict</h1>

        <div class="narrative-text">
            <p>The chamber falls silent as the last god casts their vote. The crystalline sphere at the center of the council chamber glows with an intense golden light, tallying the divine judgment.</p>

            <p><strong>VALDRIS</strong>, god of Order, speaks first: <em>"You broke sacred law, but you did so to save innocents. Law without compassion is tyranny."</em></p>

            <p><strong>KAITHA</strong>, goddess of Chaos, laughs: <em>"Rules are meant to be broken! This mortal understands true freedom."</em></p>

            <p><strong>MORVANE</strong>, god of Death, remains silent, but his skeletal hand gestures toward mercy.</p>

            <p style="text-align: center; margin: 40px 0; padding: 30px; background: rgba(212, 175, 55, 0.1); border-left: 4px solid #D4AF37;">
                <strong style="font-size: 28px; color: #FFD700;">VERDICT: 4-3 in your favor</strong><br>
                <span style="font-size: 18px;">You are spared... for now.</span>
            </p>

            <p>The gods fade back into the ethereal realm, but their presence lingers. You have been judged and found... acceptable. But they are watching. Always watching.</p>
        </div>

        <div class="choice-section">
            <h3 style="font-family: 'Cinzel', serif; color: #D4AF37; margin-bottom: 20px;">Continue your journey...</h3>
            <button class="choice-button" onclick="location.reload()">
                üîÑ Restart Demo
            </button>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // === FLOW CONTROL ===
        let currentSection = 1;

        function updateFlowIndicator(step) {
            // Reset all steps
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`step${i}`).classList.remove('active', 'completed');
                if (i < step) {
                    document.getElementById(`step${i}`).classList.add('completed');
                } else if (i === step) {
                    document.getElementById(`step${i}`).classList.add('active');
                }
            }
        }

        updateFlowIndicator(1);

        function enterCouncil() {
            // Hide narrative section
            document.getElementById('section1').style.display = 'none';

            // Show Three.js scene
            const sceneContainer = document.getElementById('threejs-section');
            sceneContainer.classList.add('active');

            updateFlowIndicator(2);

            // Initialize Three.js scene
            initThreeJSScene();
        }

        function skipScene() {
            endThreeJSScene();
        }

        function endThreeJSScene() {
            // Hide Three.js scene
            document.getElementById('threejs-section').classList.remove('active');

            // Show resolution narrative
            document.getElementById('section3').style.display = 'block';

            updateFlowIndicator(4);

            // Cleanup Three.js
            if (window.animationId) {
                cancelAnimationFrame(window.animationId);
            }
        }

        // === THREE.JS SCENE ===
        function initThreeJSScene() {
            const canvas = document.getElementById('threejs-canvas');
            const loading = document.getElementById('loading');

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x0a0812, 10, 50);

            // Camera
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            const centerLight = new THREE.PointLight(0xffd700, 2, 100);
            centerLight.position.set(0, 5, 0);
            scene.add(centerLight);

            // Create 7 God Pedestals in a circle
            const gods = [
                { name: 'VALDRIS', color: 0xd4af37, angle: 0 },
                { name: 'KAITHA', color: 0xff00ff, angle: Math.PI * 2 / 7 },
                { name: 'MORVANE', color: 0x8b0000, angle: Math.PI * 4 / 7 },
                { name: 'SYLARA', color: 0x00ff88, angle: Math.PI * 6 / 7 },
                { name: 'KORVAN', color: 0xff4444, angle: Math.PI * 8 / 7 },
                { name: 'ATHENA', color: 0x4488ff, angle: Math.PI * 10 / 7 },
                { name: 'MERCUS', color: 0xffa500, angle: Math.PI * 12 / 7 }
            ];

            const godObjects = [];
            const radius = 12;

            gods.forEach((god, index) => {
                // Pedestal
                const pedestalGeometry = new THREE.CylinderGeometry(0.8, 1, 2, 6);
                const pedestalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a2420,
                    metalness: 0.3,
                    roughness: 0.7
                });
                const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);

                const x = Math.cos(god.angle) * radius;
                const z = Math.sin(god.angle) * radius;
                pedestal.position.set(x, -1, z);
                scene.add(pedestal);

                // God Symbol (rotating torus)
                const symbolGeometry = new THREE.TorusGeometry(1, 0.3, 16, 100);
                const symbolMaterial = new THREE.MeshStandardMaterial({
                    color: god.color,
                    emissive: god.color,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.set(x, 2, z);
                symbol.rotation.x = Math.PI / 2;
                scene.add(symbol);

                // Point light for each god
                const godLight = new THREE.PointLight(god.color, 1.5, 8);
                godLight.position.set(x, 2, z);
                scene.add(godLight);

                godObjects.push({
                    symbol: symbol,
                    light: godLight,
                    pedestal: pedestal,
                    originalY: 2,
                    god: god
                });

                // Create text sprite for god name
                const canvas2d = document.createElement('canvas');
                const context = canvas2d.getContext('2d');
                canvas2d.width = 512;
                canvas2d.height = 128;
                context.fillStyle = '#' + god.color.toString(16).padStart(6, '0');
                context.font = 'bold 48px Cinzel';
                context.textAlign = 'center';
                context.fillText(god.name, 256, 80);

                const texture = new THREE.CanvasTexture(canvas2d);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, 4, z);
                sprite.scale.set(4, 1, 1);
                scene.add(sprite);
            });

            // Central voting sphere
            const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.3,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.6
            });
            const votingSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            votingSphere.position.set(0, 2, 0);
            scene.add(votingSphere);

            // Floor
            const floorGeometry = new THREE.CircleGeometry(25, 64);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0812,
                metalness: 0.5,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            scene.add(floor);

            // Add magical circle on floor
            const circleGeometry = new THREE.RingGeometry(radius - 0.5, radius, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0xd4af37,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const magicCircle = new THREE.Mesh(circleGeometry, circleMaterial);
            magicCircle.rotation.x = -Math.PI / 2;
            magicCircle.position.y = -1.9;
            scene.add(magicCircle);

            // Particles
            const particleCount = 200;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = Math.random() * 20;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

                const color = new THREE.Color(0xd4af37);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Hide loading
            loading.style.display = 'none';

            // Animation
            let time = 0;
            let votePhase = 0;
            let voteTimer = 0;

            function animate() {
                window.animationId = requestAnimationFrame(animate);

                time += 0.01;
                voteTimer += 0.016; // ~60fps

                // Rotate god symbols
                godObjects.forEach((obj, index) => {
                    obj.symbol.rotation.z += 0.01;

                    // Floating animation
                    obj.symbol.position.y = obj.originalY + Math.sin(time * 2 + index) * 0.2;

                    // Pulsing light
                    obj.light.intensity = 1.5 + Math.sin(time * 3 + index) * 0.5;
                });

                // Rotate voting sphere
                votingSphere.rotation.y += 0.01;
                votingSphere.rotation.x += 0.005;

                // Pulse voting sphere
                const scale = 1 + Math.sin(time * 2) * 0.1;
                votingSphere.scale.set(scale, scale, scale);

                // Rotate magic circle
                magicCircle.rotation.z += 0.002;

                // Animate particles
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 1] += 0.02;
                    if (positions[i * 3 + 1] > 20) {
                        positions[i * 3 + 1] = 0;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Camera rotation around the scene
                const cameraRadius = 20;
                camera.position.x = Math.sin(time * 0.1) * cameraRadius;
                camera.position.z = Math.cos(time * 0.1) * cameraRadius;
                camera.lookAt(0, 2, 0);

                // Voting animation sequence
                if (voteTimer > 2 && votePhase < 7) {
                    updateFlowIndicator(3);

                    const god = godObjects[votePhase];
                    // Highlight voting god
                    god.light.intensity = 3;
                    god.symbol.material.emissiveIntensity = 1;

                    votePhase++;
                    voteTimer = 0;
                }

                // End scene after all votes
                if (votePhase >= 7 && voteTimer > 3) {
                    endThreeJSScene();
                }

                renderer.render(scene, camera);
            }

            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
